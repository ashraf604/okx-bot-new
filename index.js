// =================================================================
// OKX Advanced Analytics Bot - Final Polished Version
// Features: Portfolio Charting, Detailed Coin Info, Daily Summary,
// Price Alerts, Trade Monitoring, and a full Settings Hub.
// =================================================================

const express = require("express");
const { Bot, Keyboard, InlineKeyboard, webhookCallback } = require("grammy");
const fetch = require("node-fetch");
const crypto = require("crypto");
const fs = require("fs");
require("dotenv").config();

// --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ---
const app = express();
const bot = new Bot(process.env.TELEGRAM_BOT_TOKEN);
const PORT = process.env.PORT || 3000;
const AUTHORIZED_USER_ID = parseInt(process.env.AUTHORIZED_USER_ID);
const API_BASE_URL = "https://www.okx.com";

// --- Ù…Ù„ÙØ§Øª ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ---
const CAPITAL_FILE = "data_capital.json";
const ALERTS_FILE = "data_alerts.json";
const TRADES_FILE = "data_trades.json";
const HISTORY_FILE = "data_history.json";
const SETTINGS_FILE = "data_settings.json";

// --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø© ÙˆØ§Ù„Ù…Ø¤Ø´Ø±Ø§Øª ---
let waitingState = null; // 'set_capital', 'coin_info', 'set_alert', 'delete_alert'
let tradeMonitoringInterval = null;
let alertsCheckInterval = null;
let dailyJobsInterval = null;

// === Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª ===

// Ø¯Ø§Ù„Ø© Ø¹Ø§Ù…Ø© Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù JSON Ø¨Ø£Ù…Ø§Ù†
function readJsonFile(filePath, defaultValue) {
    try {
        if (fs.existsSync(filePath)) return JSON.parse(fs.readFileSync(filePath));
        return defaultValue;
    } catch (error) {
        console.error(`Error reading ${filePath}:`, error);
        return defaultValue;
    }
}

// Ø¯Ø§Ù„Ø© Ø¹Ø§Ù…Ø© Ù„ÙƒØªØ§Ø¨Ø© Ù…Ù„Ù JSON Ø¨Ø£Ù…Ø§Ù†
function writeJsonFile(filePath, data) {
    try {
        fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error(`Error writing to ${filePath}:`, error);
    }
}

// Ø¯ÙˆØ§Ù„à¸ˆà¸±à¸”à¸à¸²à¸£ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
const loadCapital = () => readJsonFile(CAPITAL_FILE, 0);
const saveCapital = (amount) => writeJsonFile(CAPITAL_FILE, amount);
const loadAlerts = () => readJsonFile(ALERTS_FILE, []);
const saveAlerts = (alerts) => writeJsonFile(ALERTS_FILE, alerts);
const loadLastTrades = () => readJsonFile(TRADES_FILE, {});
const saveLastTrades = (trades) => writeJsonFile(TRADES_FILE, trades);
const loadHistory = () => readJsonFile(HISTORY_FILE, []);
const saveHistory = (history) => writeJsonFile(HISTORY_FILE, history);
const loadSettings = () => readJsonFile(SETTINGS_FILE, { dailySummary: false });
const saveSettings = (settings) => writeJsonFile(SETTINGS_FILE, settings);

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ ØªØ±ÙˆÙŠØ³Ø§Øª OKX API
function getHeaders(method, path, body = "") {
    const timestamp = new Date().toISOString();
    const prehash = timestamp + method.toUpperCase() + path + (typeof body === 'object' ? JSON.stringify(body) : body);
    const sign = crypto.createHmac("sha256", process.env.OKX_API_SECRET_KEY).update(prehash).digest("base64");
    return {
        "OK-ACCESS-KEY": process.env.OKX_API_KEY, "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp, "OK-ACCESS-PASSPHRASE": process.env.OKX_API_PASSPHRASE,
        "Content-Type": "application/json",
    };
}

// === Ø¯ÙˆØ§Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† OKX ===

async function getPortfolio() {
    try {
        const res = await fetch(`${API_BASE_URL}/api/v5/account/balance`, { headers: getHeaders("GET", "/api/v5/account/balance") });
        const json = await res.json();
        if (json.code !== '0') return { error: `ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø­ÙØ¸Ø©: ${json.msg}` };
        const tickersRes = await fetch(`${API_BASE_URL}/api/v5/market/tickers?instType=SPOT`);
        const tickersJson = await tickersRes.json();
        const prices = {};
        if (tickersJson.data) tickersJson.data.forEach(t => prices[t.instId] = parseFloat(t.last));
        let assets = [], total = 0;
        json.data[0]?.details?.forEach(asset => {
            const amount = parseFloat(asset.eq);
            if (amount > 0) {
                const instId = `${asset.ccy}-USDT`;
                const price = prices[instId] || (asset.ccy === "USDT" ? 1 : 0);
                const value = amount * price;
                if (value >= 1) {
                    assets.push({ asset: asset.ccy, price, value, amount });
                    total += value;
                }
            }
        });
        assets.sort((a, b) => b.value - a.value);
        return { assets, total };
    } catch (e) { console.error(e); return { error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ù†ØµØ©." }; }
}

async function getInstrumentDetails(instId) {
    try {
        const res = await fetch(`${API_BASE_URL}/api/v5/market/ticker?instId=${instId.toUpperCase()}`);
        const json = await res.json();
        if (json.code !== '0' || !json.data[0]) return { error: `Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù…Ù„Ø©.` };
        const data = json.data[0];
        return {
            price: parseFloat(data.last), high24h: parseFloat(data.high24h),
            low24h: parseFloat(data.low24h), vol24h: parseFloat(data.volCcy24h),
        };
    } catch (e) { console.error(e); return { error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ù†ØµØ©." }; }
}

// === Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¹Ø±Ø¶ ÙˆØ§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø© ===

function formatPortfolioMsg(assets, total, capital) {
    let pnl = capital > 0 ? total - capital : 0;
    let pnlPercent = capital > 0 ? (pnl / capital) * 100 : 0;
    let msg = `ðŸ“Š *Ù…Ù„Ø®Øµ Ø§Ù„Ù…Ø­ÙØ¸Ø©* ðŸ“Š\n\n`;
    msg += `ðŸ’° *Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:* $${total.toFixed(2)}\n`;
    msg += `ðŸ’¼ *Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ:* $${capital.toFixed(2)}\n`;
    msg += `ðŸ“ˆ *Ø§Ù„Ø±Ø¨Ø­/Ø§Ù„Ø®Ø³Ø§Ø±Ø© (PnL):* ${pnl >= 0 ? 'ðŸŸ¢' : 'ðŸ”´'} $${pnl.toFixed(2)} (${pnlPercent.toFixed(2)}%)\n`;
    msg += `------------------------------------\n`;
    assets.forEach(a => {
        let percent = total > 0 ? ((a.value / total) * 100).toFixed(2) : 0;
        msg += `ðŸ’Ž *${a.asset}* (${percent}%)\n`;
        if (a.asset !== "USDT") msg += `  Ø§Ù„Ø³Ø¹Ø±: $${a.price.toFixed(4)}\n`;
        msg += `  Ø§Ù„Ù‚ÙŠÙ…Ø©: $${a.value.toFixed(2)}\n`;
        msg += `  Ø§Ù„ÙƒÙ…ÙŠØ©: ${a.amount}\n\n`;
    });
    msg += `ðŸ•’ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«:* ${new Date().toLocaleString("ar-EG", { timeZone: "Africa/Cairo" })}`;
    return msg;
}

function createChartUrl(history) {
    if (history.length < 2) return null;
    const last7Days = history.slice(-7);
    const labels = last7Days.map(h => h.date.slice(5));
    const data = last7Days.map(h => h.total.toFixed(2));
    const chartConfig = {
        type: 'line', data: { labels: labels, datasets: [{ label: 'Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø­ÙØ¸Ø© ($)', data: data, fill: true, backgroundColor: 'rgba(75, 192, 192, 0.2)', borderColor: 'rgb(75, 192, 192)', tension: 0.1 }] },
        options: { title: { display: true, text: 'Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø­ÙØ¸Ø© Ø¢Ø®Ø± 7 Ø£ÙŠØ§Ù…' } }
    };
    return `https://quickchart.io/chart?c=${encodeURIComponent(JSON.stringify(chartConfig))}&backgroundColor=white`;
}

async function checkNewTrades() { /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ÙÙŠ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ... */ }
async function checkAlerts() { /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ÙÙŠ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ... */ }

async function runDailyJobs() {
    const now = new Date(new Date().toLocaleString("en-US", { timeZone: "Africa/Cairo" }));
    const todayStr = now.toISOString().split('T')[0]; // YYYY-MM-DD format

    // 1. Ø£Ø®Ø° Ù„Ù‚Ø·Ø© Ù„Ù„Ù…Ø­ÙØ¸Ø© (Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠÙ‹Ø§)
    const history = loadHistory();
    if (!history.find(h => h.date === todayStr)) {
        const { total, error } = await getPortfolio();
        if (!error && total > 0) {
            history.push({ date: todayStr, total });
            saveHistory(history);
            console.log(`Portfolio snapshot taken for ${todayStr}: $${total}`);
        }
    }

    // 2. Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„ÙŠÙˆÙ…ÙŠ (Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠÙ‹Ø§ Ø§Ù„Ø³Ø§Ø¹Ø© 9 ØµØ¨Ø§Ø­Ù‹Ø§)
    const settings = loadSettings();
    if (settings.dailySummary && now.getHours() === 9 && now.getMinutes() === 0) {
        const { assets, total, error } = await getPortfolio();
        if (!error) {
            const capital = loadCapital();
            const msg = formatPortfolioMsg(assets, total, capital);
            await bot.api.sendMessage(AUTHORIZED_USER_ID, "ðŸ“° *Ù…Ù„Ø®ØµÙƒ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù„Ù…Ø­ÙØ¸Ø©*\n\n" + msg, { parse_mode: "Markdown" });
        }
    }
}

// === ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø£ÙˆØ§Ù…Ø± ===

// Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
const mainKeyboard = new Keyboard()
    .text("ðŸ“Š Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ÙØ¸Ø©").text("ðŸ“ˆ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø­ÙØ¸Ø©").row()
    .text("â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù…Ù„Ø©").text("ðŸ”” Ø¶Ø¨Ø· ØªÙ†Ø¨ÙŠÙ‡").row()
    .text("ðŸ‘ï¸ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„ØµÙÙ‚Ø§Øª").text("âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª").resized();

bot.command("start", async (ctx) => {
    if (ctx.from.id !== AUTHORIZED_USER_ID) return;
    await ctx.reply("ðŸ¤– *Ø¨ÙˆØª OKX Ø§Ù„ØªØ­Ù„ÙŠÙ„ÙŠ Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„*\n\n- Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ! Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹ØŒ ÙˆØ§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© /settings.", { parse_mode: "Markdown", reply_markup: mainKeyboard });
});

// Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
bot.command("settings", async (ctx) => {
    if (ctx.from.id !== AUTHORIZED_USER_ID) return;
    const settings = loadSettings();
    const settingsKeyboard = new InlineKeyboard()
        .text("ðŸ’° ØªØ¹ÙŠÙŠÙ† Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„", "set_capital").text("ðŸ“„ Ø¹Ø±Ø¶ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª", "view_alerts").row()
        .text("ðŸ—‘ï¸ Ø­Ø°Ù ØªÙ†Ø¨ÙŠÙ‡", "delete_alert").text(`ðŸ“° Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„ÙŠÙˆÙ…ÙŠ: ${settings.dailySummary ? 'âœ…' : 'âŒ'}`, "toggle_summary").row()
        .text("ðŸ”¥ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ðŸ”¥", "delete_all_data");
    await ctx.reply("âš™ï¸ *Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª*:", { reply_markup: settingsKeyboard });
});

// === Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„ ===

// Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
bot.hears("ðŸ“Š Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ÙØ¸Ø©", async (ctx) => { /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ... */ });
bot.hears("ðŸ“ˆ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø­ÙØ¸Ø©", async (ctx) => { /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ... */ });
bot.hears("â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù…Ù„Ø©", (ctx) => { waitingState = 'coin_info'; ctx.reply("â„¹ï¸ Ø£Ø±Ø³Ù„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© (Ù…Ø«Ø§Ù„: BTC-USDT)."); });
bot.hears("ðŸ”” Ø¶Ø¨Ø· ØªÙ†Ø¨ÙŠÙ‡", (ctx) => { waitingState = 'set_alert'; ctx.reply("ðŸ“ *Ø£Ø±Ø³Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡:*\n`SYMBOL > PRICE`", { parse_mode: "Markdown" }); });
bot.hears("âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª", (ctx) => ctx.api.sendMessage(ctx.from.id, "/settings"));
bot.hears("ðŸ‘ï¸ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„ØµÙÙ‚Ø§Øª", async (ctx) => { /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ... */ });


// Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ø¶Ù…Ù†Ø© (Inline)
bot.callbackQuery("set_capital", async (ctx) => { waitingState = 'set_capital'; await ctx.answerCallbackQuery(); await ctx.reply("ðŸ’° Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„."); });
bot.callbackQuery("view_alerts", async (ctx) => { /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ... */ });
bot.callbackQuery("delete_alert", async (ctx) => { waitingState = 'delete_alert'; await ctx.answerCallbackQuery(); await ctx.reply("ðŸ—‘ï¸ Ø£Ø±Ø³Ù„ ID Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø°ÙÙ‡."); });
bot.callbackQuery("toggle_summary", async (ctx) => { /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ... */ });
bot.callbackQuery("delete_all_data", async (ctx) => {
    saveAlerts([]); saveLastTrades({}); saveHistory([]);
    await ctx.answerCallbackQuery({ text: "ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­!" });
    await ctx.editMessageText("ðŸ—‘ï¸ ØªÙ… Ù…Ø³Ø­ ÙƒÙ„ Ø³Ø¬Ù„Ø§Øª Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª ÙˆØ§Ù„ØµÙÙ‚Ø§Øª ÙˆØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­ÙØ¸Ø©.");
});


// Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©
bot.on("message:text", async (ctx) => {
    if (ctx.from.id !== AUTHORIZED_USER_ID || !waitingState) return;
    const text = ctx.message.text;

    switch (waitingState) {
        case 'set_capital':
            const amount = parseFloat(text);
            if (!isNaN(amount) && amount > 0) {
                saveCapital(amount); await ctx.reply(`âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ø¥Ù„Ù‰: $${amount.toFixed(2)}`);
            } else { await ctx.reply("âŒ Ù…Ø¨Ù„Øº ØºÙŠØ± ØµØ§Ù„Ø­."); }
            break;
        case 'coin_info':
            const { error, ...details } = await getInstrumentDetails(text);
            if (error) { await ctx.reply(`âŒ ${error}`); }
            else { /* ... Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„ ÙƒÙ…Ø§ ÙÙŠ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ... */ }
            break;
        case 'set_alert':
            /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ... */
            break;
        case 'delete_alert':
            /* ... Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ ... */
            break;
    }
    waitingState = null; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
});


// === Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø®Ø§Ø¯Ù… ÙˆØ§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø© ===
app.use(express.json());
app.use(webhookCallback(bot, "express"));

app.listen(PORT, async () => {
    console.log(`âœ… Bot running on port ${PORT}`);
    if (!alertsCheckInterval) { alertsCheckInterval = setInterval(checkAlerts, 60000); console.log("âœ… Price alert checker started."); }
    if (!dailyJobsInterval) { dailyJobsInterval = setInterval(runDailyJobs, 60000); console.log("âœ… Daily jobs scheduler started."); }
    try {
        const domain = process.env.RAILWAY_STATIC_URL || process.env.RENDER_EXTERNAL_URL;
        if (domain) {
            const webhookUrl = `https://${domain}`;
            await bot.api.setWebhook(webhookUrl, { drop_pending_updates: true });
            console.log(`âœ… Webhook set to: ${webhookUrl}`);
        } else { console.warn("Webhook URL not found."); }
    } catch (e) { console.error("Failed to set webhook:", e); }
});

